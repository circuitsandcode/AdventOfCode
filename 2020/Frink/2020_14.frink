// Solution for 2020 Day 14: Docking Data
// https://adventofcode.com/2020/day/14
// Written in Frink by Chris Hansen
// Website: https://circuitsandcode.wehappyfew.net/
// Twitter: https://twitter.com/CircuitsAndCode
// Github: https://github.com/circuitsandcode
// MIT License: https://github.com/circuitsandcode/AdventOfCode/blob/master/LICENSE

start = now[]

// Sample Input
strInput = ["mask = 000000000000000000000000000000X1001X",
	"mem[42] = 100",
	"mask = 00000000000000000000000000000000X0XX",
	"mem[26] = 1"]

// Import the input file using the readLines function. This will import the file into an array.
// The input string is relative to my frink.jar file. Adjust this to the absolute or relative path with your input file.
// Note that the variable name is the same as the sample input again. Comment out this line to run the sample input.
strInput = readLines["file:../Projects/AdventOfCode/2020/InputFiles/2020_14_input.txt"]

// Create dictionaries for part I and II
memDict = new dict
memDict2 = new dict

// Loop through the input string
for str = strInput
{
	// First check if the current line is setting a mask value.
	if str =~ %r/mask/
	{
		// Capture everything that appears after the phrase "mask = "
		// This will be something like "000000000000000000000000000000X1001X"
		mask = str =~ %r/mask = (.+)/
		// Results are returned to an array so this pulls the value into a simple string.
		mask = mask@0
		// Copy the mask variable into And and Or versions for the upcoming bitwise functions.
		maskAnd = mask
		maskOr = mask
		// Replace the Xs with 1s and 0s for the And and Or versions.
		maskAnd =~ %s/X/1/g
		maskOr =~ %s/X/0/g
		// The result is a sting of binary numbers. Convert these to ints.
		maskAndInt = parseInt[maskAnd,2]
		maskOrInt = parseInt[maskOr,2]

		// Everything below in this if statement is for Part II.
		// Break the mask into an array so we can easily find the position of all the Xs.
		maskArr = charList[mask]
		xPositions = new array
		i = 0
		for maskChar = maskArr
		{
			if maskChar == "X"
				xPositions.push[i]
			i = i+1
		}
		// Grab the length of the array (number of Xs) for use later in the code.
		xMemLength = length[xPositions]
	}
	// Anything that isn't a mask is a key value pair.
	if str =~ %r/\[\d+\]/
	{
		// Grab the vals of the key (number in square brackets) and value (number after the equals sign). Then parse those into ints.
		val = str =~ %r/\[(\d+)\]\s=\s(\d+)/
		valKey = parseInt[val@0]
		valNum = parseInt[val@1]
		valNum2 = valNum // Make a second copy for Part II. This preserves the original value since it is not modified in Part II.
		// Modify the valNums by applying a bitAnd and a bitOr (in that order) to get the modifications required by the mask.
		valNum = bitAnd[valNum,maskAndInt]
		valNum = bitOr[valNum,maskOrInt]
		// Set the modified value in the dictinary with the matching key.
		memDict@valKey = valNum

		// Everything below in this if statement is for is for Part II.
		valKey2 = bitOr[valKey,maskOrInt] // Replace all 1s in the memory address.
		// Create a set to track the different possible keys. The set will ensure uniqueness.
		keySet = new set
		// Use the grayCode function to make every possible iteration of 1 and 0 for each X in the xPositions array.
		bitsReplace = grayCode[2, xMemLength]
		// Convert the modified key value to binary, then to string, then to array.
		valKey2Str = charList[toString[binary[valKey2]]] 
		// If the resulting array is less than 36 characters (due to the leftmost bits not being zero) add in leading zeros
		if length[valKey2Str] < 36
		{
			for zeroItem = 1 to (36 - length[valKey2Str])
			{
				valKey2Str.pushFirst["0"]
			}
		}
		// Loop through each replacement pattern generated by the grayCode above.
		for bitReplace = bitsReplace
		{
			// Combine the Positions array to determine the bit that needs to be replaced with the bitReplace value.
			// Set the new valu to the valKey2Str array.
			for i = 0 to length[xPositions]-1
			{
				valKey2Str@(xPositions@i) = bitReplace@i
				i = i+1
			}
			// Combine the resulting array modifications into a single string and then parse it as a binary int. The put the key into the set.
			valKey2Joined = parseInt[join["",valKey2Str],2]
			keySet.put[valKey2Joined]
		}
		// Then loop through the set and add the key value into the dictionary with the associated value.
		for keySetItem = keySet
		{
			memDict2@keySetItem = valNum2
		}
	}
}

// Part I. Add up the total of all values in the Part I and II dictionaries.
total = 0
for memKey = memDict.keys[]
{
   total = total + memDict@memKey
}

println["Part I: The total of all values in memory is $total"] // Part I

total = 0
for memKey = memDict2.keys[]
{
   total = total + memDict2@memKey
}

println["Part II: The total of all values in memory is $total"] // Part II

end = now[]
println["Program run time: " + ((end - start)*1.0 -> "seconds")]