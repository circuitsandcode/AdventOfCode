// Solution for 2021 Day 11: Dumbo Octopus
// https://adventofcode.com/2021/day/11
// Written in Frink by Chris Hansen
// Website: https://www.circuitsandcode.net/
// Twitter: https://twitter.com/CircuitsAndCode
// Github: https://github.com/circuitsandcode
// MIT License: https://github.com/circuitsandcode/AdventOfCode/blob/master/LICENSE

start = now[]

// Prepare Sample Input
sampleInput = """5483143223
2745854711
5264556173
6141336146
6357385478
4167524645
2176841721
6882881134
4846848554
5283751526"""

sampleInput = trim[read["file:../Projects/AdventOfCode/2021/InputFiles/2021_11_CTH_input.txt"]]

sampleSolution1 = 1656
sampleSolution2 = 1134

// Variable to count the flashes
flashCounter = 0

// Create a set to track all dumbo octopus that flashed this cycle
flashedSet = new set

// Create a set to track level 10 Octopi
OctopiEnergy10 = new set

// Function to increase adjascent octopuses
adjascentIncrease[centerDumboOctopus,centerDumboOctopusGrid] :=
{
	centerOctopiEnergy10 = new set
	dumboOctopusX = centerDumboOctopus@1
	dumboOctopusY = centerDumboOctopus@0
	// Set energyBounds for all octopus
	energyBounds = [new range[-1,1], new range[-1,1]]
	INCREASELOOP:
	multifor [xMod,yMod] = energyBounds
	{
		adjacentX = dumboOctopusX + xMod
		adjacentY = dumboOctopusY + yMod
		adjacentValue = centerDumboOctopusGrid@adjacentY@adjacentX
		if (xMod == 0 && yMod == 0) || adjacentValue == -1 || adjacentValue == 0 || adjacentValue == 10
		{
			next INCREASELOOP
		}
		centerDumboOctopusGrid@adjacentY@adjacentX = adjacentValue + 1
		if centerDumboOctopusGrid@adjacentY@adjacentX == 10
		{
			centerOctopiEnergy10.put[[adjacentY,adjacentX]]
		}
	}
	return [centerDumboOctopusGrid,centerOctopiEnergy10]
}

dumboGrid = new array
// Add border of -1 digits that the program will ignore. This saves the trouble of writing edge detecting logic.
gridBorder = makeArray[[12], -1]
dumboGrid.push[gridBorder]
dumboInputLineStr = splitLines[sampleInput]
for dumboLine = dumboInputLineStr
{
	dumboInputArr = map["parseInt",charList[dumboLine]]
	dumboInputArr.push[-1]
	dumboInputArr.pushFirst[-1]
	dumboGrid.push[dumboInputArr]
}
dumboGrid.push[gridBorder]

// Set bounds for the grid of dumbo octopus
// This ignores the border of -1 fields

// Optional Animation
// Need to adjust this to 1/100 values
// Use this syntax
// new color[r, g, b]
colorDict = new dict
colorDict@0 = [225,245,254]
colorDict@1 = [1,87,155]
colorDict@2 = [2,119,189]
colorDict@3 = [2,136,209]
colorDict@4 = [3,155,229]
colorDict@5 = [3,169,244]
colorDict@6 = [41,182,246]
colorDict@7 = [79,195,247]
colorDict@8 = [129,212,250]
colorDict@9 = [179,229,252]

colorConvertRGB[colorArr] :=
{
	colorCovert = { |x| round[x/255,.001] }
	return map[colorCovert,colorArr]
}

for i = 0 to 9
{
	colorDict@i = colorConvertRGB[colorDict@i]
}
/*
println[colorDict]

g = new graphics
g.backgroundColor[0,0,0]
for i = 0 to 9
{
	rgb = colorDict@i
	println[rgb]
	red = rgb@0
	green = rgb@1
	blue = rgb@2
	if i == 0
		bgColorVal = 1
	else
		bgColorVal = (i/10)-.1
	g.color[bgColorVal,bgColorVal,bgColorVal]
	x = i * 10
	g.fillEllipseCenter[x,0,10,10]
	//println[bgColorVal]
	g.color[red,green,blue]
	g.fillEllipseCenter[x,0,9,9]
}
g.show[]
*/
a = new Animation[5/s]
//firstRoundAllFlash = 0
i = 0
cycle100 = false
allFlash = false
bounds = [new range[1,10],new range[1,10]]
//for i = 1 to 100
until allFlash == true && cycle100 == true
{
	i = i+1
	//println["Beginning step $i:"]
	// Clear the flashed set each cycle
	flashedSet.clear
	OctopiEnergy10.clear
	flashRound = 0
	multifor[dumboY,dumboX] = bounds
	{
		dumbo = [dumboY,dumboX]
		dumboGrid@dumboY@dumboX = (dumboGrid@dumboY@dumboX) + 1
		if dumboGrid@dumboY@dumboX == 10
		{
			dumbo = [dumboY,dumboX]
			OctopiEnergy10.put[dumbo]
		}
	}
	while length[OctopiEnergy10] > 0
	{
		for dumbo10 = OctopiEnergy10
		{
			dumbo10X = dumbo10@1
			dumbo10Y = dumbo10@0
			dumboGrid@dumbo10Y@dumbo10X = 0
			adjascentIncreased = adjascentIncrease[dumbo10,dumboGrid]
			dumboGrid = adjascentIncreased@0
			OctopiEnergy10 = union[OctopiEnergy10,adjascentIncreased@1]
			flashCounter = flashCounter + 1
			flashRound = flashRound + 1
			OctopiEnergy10.remove[dumbo10]
		}
		//println["Total Flashes round $i is $flashRound"]
		
		if allFlash == false && flashRound == 100
		{
			firstRoundAllFlash = i
			allFlash = true
		}
	}
	g = new graphics
	g.backgroundColor[0,0,0]
	multifor[ycor,xcor] = bounds
	{
		xplot = xcor * 10
		yplot = ycor * 10
		plotval = dumboGrid@ycor@xcor
		rgb = colorDict@plotval
		//println[rgb]
		red = rgb@0
		green = rgb@1
		blue = rgb@2
		if plotval == 0
			bgColorVal = 1
		else
			bgColorVal = (plotval/10)-.1
		g.color[bgColorVal,bgColorVal,bgColorVal]
		//x = i * 10
		g.fillEllipseCenter[xplot,yplot,10,10]
		//println[bgColorVal]
		g.color[red,green,blue]
		g.fillEllipseCenter[xplot,yplot,9,9]
	}
	a.add[g]
	if i == 100
	{
		cycle100 = true
		println["flashCounter at 100 rounds is: $flashCounter"]
	}
}

//println["flashCounter is: $flashCounter"]
println["First round all flashed: $firstRoundAllFlash"]
println["Writing animation"]
a.write["OctopiAnimation1.gif", 500, 500]
println["Done writing animation"]

// Run the sample input
//basinParser[sampleInput,sampleSolution1,sampleSolution2]
// Run the import
//basinParser[basinInputData]

end = now[]
println["Program run time: " + ((end - start)*1.0 -> "seconds")]