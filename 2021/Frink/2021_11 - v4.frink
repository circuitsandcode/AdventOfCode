// Solution for 2021 Day 11: Dumbo Octopus
// https://adventofcode.com/2021/day/11
// Written in Frink by Chris Hansen
// Website: https://www.circuitsandcode.net/
// Twitter: https://twitter.com/CircuitsAndCode
// Github: https://github.com/circuitsandcode
// MIT License: https://github.com/circuitsandcode/AdventOfCode/blob/master/LICENSE

start = now[]

// Prepare Sample Input
sampleInput = """5483143223
2745854711
5264556173
6141336146
6357385478
4167524645
2176841721
6882881134
4846848554
5283751526"""

sampleSolution1 = 1656
sampleSolution2 = 1134

// Variable to count the flashes
flashCounter = 0

// Create a set to track all dumbo octopus that flashed this cycle
flashedSet = new set

// Create a set to track level 10 Octopi
OctopiEnergy10 = new set

// Function to increase adjascent octopuses
adjascentIncrease[centerDumboOctopus,centerDumboOctopusGrid] :=
{
	dumboOctopusX = centerDumboOctopus@1
	dumboOctopusY = centerDumboOctopus@0
	// Set energyBounds for all octopus
	energyBounds = [new range[-1,1], new range[-1,1]]
	INCREASELOOP:
	multifor [xMod,yMod] = energyBounds
	{
		adjacentX = dumboOctopusX + xMod
		adjacentY = dumboOctopusY + yMod
		adjacentValue = centerDumboOctopusGrid@adjacentY@adjacentX
		if (xMod == 0 && yMod == 0) || adjacentValue == 10 || adjacentValue == -1 || adjacentValue == 0
		{
			next INCREASELOOP
		}
		centerDumboOctopusGrid@adjacentY@adjacentX = adjacentValue + 1
	}
	return centerDumboOctopusGrid
}

//function defintion
energyFlash[dumboOctopus,dumboOctopusGrid,dumboFlashedSet,flashCount] :=
{
	//println[dumboOctopus]
	dumboOctopusX = dumboOctopus@1
	dumboOctopusY = dumboOctopus@0
	dumboVal = dumboOctopusGrid@dumboOctopusY@dumboOctopusX
	if dumboFlashedSet.contains[dumboOctopus] || dumboVal == -1
	{
		return false
	} else
	{
		if dumboOctopusGrid@dumboOctopusY@dumboOctopusX == 10
		{
			println["We have a flash on $dumboOctopus!"]
			dumboOctopusGrid@dumboOctopusY@dumboOctopusX = 0
			dumboFlashedSet.put[dumboOctopus]
			flashCount = flashCount + 1
			// Set energyBounds for all octopus
			// Call adjascentIncrease function and set the new grid
			internalDumboOctopusGrid =  adjascentIncrease[dumboOctopus,dumboOctopusGrid]
			// Loop through all adjascent based on new grid
			energyBounds = [new range[-1,1], new range[-1,1]]
			FLASHLOOP:
			multifor [xMod,yMod] = energyBounds
			{
				if xMod == 0 && yMod == 0
				{
					next FLASHLOOP
				}
				adjacentX = dumboOctopusX + xMod
				adjacentY = dumboOctopusY + yMod
				adjacentOctopus = [adjacentY,adjacentX]
				dumboResult = energyFlash[adjacentOctopus,internalDumboOctopusGrid,dumboFlashedSet,0]
				if dumboResult != false
				{
					dumboOctopusGrid = dumboResult@0
					dumboFlashedSet = union[dumboFlashedSet,dumboResult@1]
					flashCount = flashCount + dumboResult@2
				}
			}
			println["Grid after $dumboOctopus flash:"]
			for gridLine = dumboOctopusGrid
			{
				println[gridLine]
			}
		}
			return [dumboOctopusGrid,dumboFlashedSet,flashCount]
	}
}

dumboGrid = new array
// Add border of -1 digits that the program will ignore. This saves the trouble of writing edge detecting logic.
gridBorder = makeArray[[12], -1]
dumboGrid.push[gridBorder]
dumboInputLineStr = splitLines[sampleInput]
for dumboLine = dumboInputLineStr
{
	dumboInputArr = map["parseInt",charList[dumboLine]]
	dumboInputArr.push[-1]
	dumboInputArr.pushFirst[-1]
	dumboGrid.push[dumboInputArr]
}
dumboGrid.push[gridBorder]

// Set bounds for the grid of dumbo octopus
// This ignores the border of -1 fields

bounds = [new range[1,10],new range[1,10]]
for i = 1 to 5
{
	println["Beginning step $i:"]
	// Clear the flashed set each cycle
	flashedSet.clear
	OctopiEnergy10.clear
	multifor[dumboY,dumboX] = bounds
	{
		dumboGrid@dumboY@dumboX = (dumboGrid@dumboY@dumboX) + 1
	}
	println["After step $i natural increase:"]
	for gridLine = dumboGrid
	{
		println[gridLine]
	}
	multifor[dumboY,dumboX] = bounds
	{
		if dumboGrid@dumboY@dumboX == 10
		{
			// Make an array of the coordinates
			dumbo = [dumboY,dumboX]
			energyResult = energyFlash[dumbo,dumboGrid,flashedSet,0]
			if energyResult != false
			{
				// The grid will change every time
				dumboGrid = energyResult@0
				flashCounter = flashCounter + energyResult@2
				flashedSet = union[flashedSet,energyResult@1]
			}
		}
	}
	println["After step $i:"]
	for gridLine = dumboGrid
	{
		println[gridLine]
	}
}


println["flashCounter is: $flashCounter"]



// Run the sample input
//basinParser[sampleInput,sampleSolution1,sampleSolution2]
// Run the import
//basinParser[basinInputData]

end = now[]
println["Program run time: " + ((end - start)*1.0 -> "seconds")]