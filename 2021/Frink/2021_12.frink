// Solution for 2021 Day 11: Dumbo Octopus
// https://adventofcode.com/2021/day/11
// Written in Frink by Chris Hansen
// Website: https://www.circuitsandcode.net/
// Twitter: https://twitter.com/CircuitsAndCode
// Github: https://github.com/circuitsandcode
// MIT License: https://github.com/circuitsandcode/AdventOfCode/blob/master/LICENSE

start = now[]

// Prepare Sample Input
sampleInput = """dc-end
HN-start
start-kj
dc-start
dc-HN
LN-dc
HN-end
kj-sa
kj-HN
kj-dc"""

sampleSolution1 = 1656
sampleSolution2 = 1134

sampleInputArr = splitLines[sampleInput]

// Read the input file and process it through all functions (trim because there is a newline character at the end of the file
// The input string is relative to my frink.jar file. Adjust this to the absolute or relative path with your input file.
//pathInput = readLines["file:../Projects/AdventOfCode/2021/InputFiles/2021_12_input.txt"]
//println[pathInput]

pathMapper[caveInput,sampleSolution1=0,sampleSolution2=0] :=
{
	cavePaths = new array
	for caveSegments = caveInput
	{
		segmentArr = caveSegments =~ %r/^(\w+)\-(\w+)$/
		cavePaths.push[segmentArr]
	}
	//println[cavePaths]
	cavePathDict = new dict
	for cavePath = cavePaths
	{
		//println[cavePath]
		caveSet0 = new set[cavePath@0]
		caveSet1 = new set[cavePath@1]
		caveKey0 = cavePath@0
		caveKey1 = cavePath@1
		//println["caveKey0 is $caveKey0"]
		//println["caveSet0 is $caveSet0"]
		if !cavePathDict.containsKey[caveKey0]
			cavePathDict@caveKey0 = new set
		if !cavePathDict.containsKey[caveKey1]
			cavePathDict@caveKey1 = new set
		//println["cavePathDict is $cavePathDict"]
		cavePathDict@caveKey0 = union[cavePathDict@caveKey0,caveSet1]
		cavePathDict@caveKey1 = union[cavePathDict@caveKey1,caveSet0]
	}
	println["cavePathDict is $cavePathDict"]
	//println[cavePathDict]
	// Set variables to calcualte the paths
	traversedSmallCavesSet = new set["start"]
	traversedCavesArr = new array
	possiblePathsSet = new set
	// Create a recursive function to call each set
	nextCave[caveDict,startCave,traversedSmallCaves,traversedCaves,possiblePaths] :=
	{
		println["startCave is $startCave"]
		if startCave == "end"
		{
			//traversedCaves.push[startCave]
			println["traversedCaves at end are: $traversedCaves"]
			possiblePaths.put[traversedCaves]
			println["possiblePaths at end are: $possiblePaths"]
		} else
		{
			possibleNextCaves = caveDict@startCave
			println["possibleNextCaves are $possibleNextCaves"]
			traverseOptions = length[possibleNextCaves]
			//traversedCaves
			// Count small caves we can't travel through again
			blockedPaths = 0
			CAVELOOP:
			for possibleNextCave = possibleNextCaves
			{
				if traversedSmallCaves.contains[possibleNextCave]
				{
					blockedPaths = blockedPaths + 1
					if blockedPaths == traverseOptions
					{
						// End of line
						println["Cannot move forward."]
					}
					//next CAVELOOP
					return false
				} else
				{
					traversedCaves.push[possibleNextCave]
					if possibleNextCave =~ %r/^[a-z]+$/
					{
						traversedSmallCaves.put[possibleNextCave]
						println["traversedSmallCaves are: $traversedSmallCaves"]
					}
					pathToEnd = nextCave[caveDict,possibleNextCave,traversedSmallCaves,traversedCaves,possiblePaths]
					if pathToEnd != false
					{
						possiblePaths.put[pathToEnd]
					} else
					{
						next CAVELOOP
					}
				}
			}
		}
		return[possiblePaths]
	}
	// Start in start
	traversedCavesArr.push["start"]
	possiblePathsArrTotal = nextCave[cavePathDict,"start",traversedSmallCavesSet,traversedCavesArr,possiblePathsSet]
	println["possiblePathsArrTotal are $possiblePathsArrTotal"]
}

pathMapper[sampleInputArr]

end = now[]
println["Program run time: " + ((end - start)*1.0 -> "seconds")]