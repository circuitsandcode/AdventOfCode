// Solution for 2021 Day 11: Dumbo Octopus
// https://adventofcode.com/2021/day/11
// Written in Frink by Chris Hansen
// Website: https://www.circuitsandcode.net/
// Twitter: https://twitter.com/CircuitsAndCode
// Github: https://github.com/circuitsandcode
// MIT License: https://github.com/circuitsandcode/AdventOfCode/blob/master/LICENSE

start = now[]

// Prepare Sample Input
sampleInput = """dc-end
HN-start
start-kj
dc-start
dc-HN
LN-dc
HN-end
kj-sa
kj-HN
kj-dc"""

sampleSolution1 = 1656
sampleSolution2 = 1134

sampleInputArr = splitLines[sampleInput]

// Read the input file and process it through all functions (trim because there is a newline character at the end of the file
// The input string is relative to my frink.jar file. Adjust this to the absolute or relative path with your input file.
caveInputFile = readLines["file:../Projects/AdventOfCode/2021/InputFiles/2021_12_CTH_input.txt"]

// Read the input file and process it through all functions (trim because there is a newline character at the end of the file
// The input string is relative to my frink.jar file. Adjust this to the absolute or relative path with your input file.
//pathInput = readLines["file:../Projects/AdventOfCode/2021/InputFiles/2021_12_input.txt"]
//println[pathInput]

pathMapper[caveInput,sampleSolution1=0,sampleSolution2=0] :=
{
	cavePaths = new array
	for caveSegments = caveInput
	{
		segmentArr = caveSegments =~ %r/^(\w+)\-(\w+)$/
		cavePaths.push[segmentArr]
	}
	//println[cavePaths]
	cavePathDict = new dict
	for cavePath = cavePaths
	{
		//println[cavePath]
		caveSet0 = cavePath@0
		caveSet1 = cavePath@1
		caveKey0 = cavePath@0
		caveKey1 = cavePath@1
		//println["caveKey0 is $caveKey0"]
		//println["caveSet0 is $caveSet0"]
		if !cavePathDict.containsKey[caveKey0]
			cavePathDict@caveKey0 = new array
		if !cavePathDict.containsKey[caveKey1]
			cavePathDict@caveKey1 = new array
		//println["cavePathDict is $cavePathDict"]
		(cavePathDict@caveKey0).push[caveSet1]
		(cavePathDict@caveKey1).push[caveSet0]
	}
	println["cavePathDict is $cavePathDict"]
	// Part I
	queue = [["start"]]
	finished = 0
	i = 0
	while length[queue] != 0
	{
		i = i + 1
		//println["Round $i"]
		path = queue.popFirst[]
		//println["path is $path"]
		//pathLast = length[path] - 1
		//pathVal = path@pathLast
		// Get the last item on the current path array without removing it
		pathVal = path.peek[]
		//println["pathVal is $pathVal"]
		pathLastVal = cavePathDict@pathVal
		for next_node = pathLastVal
		{
			//println["next_node is $next_node"]
			if next_node == "end"
			{
				finished = finished + 1
				//println["finished is $finished"]
			} else
			{
				next_node_lower = false
				if next_node =~ %r/^[a-z]+$/
				{
					next_node_lower = true
				}
				//println["next_node_lower is $next_node_lower"]
				if !next_node_lower || !path.contains[next_node]
				{
					val = new array
					val = deepCopy[path]
					val.push[next_node]
					//println["val is $val"]
					queue.push[val]
					//println["queue is $queue"]
				}
			}
		}
	}

	println["Part I is $finished"]

	// Part II
	queue = [["start"]]
	finished = 0
	i = 0
	while length[queue] != 0
	{
		i = i + 1
		//println["Round $i"]
		path = queue.popFirst[]
		//println["path is $path"]
		//pathLast = length[path] - 1
		//pathVal = path@pathLast
		// Get the last item on the current path array without removing it
		pathVal = path.peek[]
		//println["pathVal is $pathVal"]
		pathLastVal = cavePathDict@pathVal
		for next_node = pathLastVal
		{
			// Check if we've already been in the small cave
			next_node_lower = false
			repeatedCave = false
			if next_node =~ %r/^[a-z]+$/
			{
				next_node_lower = true
			}
			//println["next_node_lower is $next_node_lower"]
			if next_node_lower == true && path.contains[next_node]
			{
				repeatedCave = true
			}
			//println["next_node is $next_node"]
			if next_node == "end"
			{
				finished = finished + 1
				//println["finished is $finished"]
			} else
			{
				if next_node != "start" && !(path@0 == "###" && repeatedCave)
				{
					val = new array
					val = deepCopy[path]
					if repeatedCave
					{
						val.pushFirst["###"]
					}
					val.push[next_node]
					//println["val is $val"]
					queue.push[val]
					//println["queue is $queue"]
				}
			}
		}
	}

	println["Part II is $finished"]
}

pathMapper[sampleInputArr]
pathMapper[caveInputFile]

end = now[]
println["Program run time: " + ((end - start)*1.0 -> "seconds")]